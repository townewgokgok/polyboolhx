-- Generated by Haxe 3.4.2
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local Array = _hx_e()
local BuildLog = _hx_e()
local Date = _hx_e()
local Epsilon = _hx_e()
local GeoJSON = _hx_e()
local GeoJSONNode = _hx_e()
local Intersecter = _hx_e()
local LinkedList = _hx_e()
local Main = _hx_e()
local Math = _hx_e()
local PolyBool = _hx_e()
local Reflect = _hx_e()
local SegmentChainer = _hx_e()
local SegmentSelector = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
local haxe = {}
haxe.IMap = _hx_e()
haxe.Json = _hx_e()
haxe.Log = _hx_e()
haxe.ds = {}
haxe.ds.StringMap = _hx_e()
haxe.format = {}
haxe.format.JsonParser = _hx_e()
haxe.format.JsonPrinter = _hx_e()
haxe.io = {}
haxe.io.Eof = _hx_e()
local lua = {}
lua.Boot = _hx_e()
lua.UserData = _hx_e()
lua.Thread = _hx_e()
local sys = {}
sys.io = {}
sys.io.File = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = {}
Array.__name__ = true
Array.prototype = _hx_a(
  'concat', function(self,a) 
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do 
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(i);
      end;
    local ret = _g;
    local _g3 = 0;
    while (_g3 < a.length) do 
      local i1 = a[_g3];
      _g3 = _g3 + 1;
      ret:push(i1);
      end;
    do return ret end
  end,
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'pop', function(self) 
    if (self.length == 0) then 
      do return nil end;
    end;
    local rawlength = _G.rawget(self,"length");
    local ret = _G.rawget(self,rawlength - 1);
    _G.rawset(self,"length",rawlength - 1);
    do return ret end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'reverse', function(self) 
    local tmp;
    local i = 0;
    while (i < Std.int(self.length / 2)) do 
      tmp = self[i];
      self[i] = self[(self.length - i) - 1];
      self[(self.length - i) - 1] = tmp;
      i = i + 1;
      end;
  end,
  'shift', function(self) 
    if (self.length == 0) then 
      do return nil end;
    end;
    local ret = self[0];
    local _g1 = 0;
    local _g = self.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[i] = self[i + 1];
      end;
    local tmp = self;
    tmp.length = tmp.length - 1;
    do return ret end
  end,
  'slice', function(self,pos,_end) 
    if ((_end == nil) or (_end > self.length)) then 
      _end = self.length;
    else
      if (_end < 0) then 
        _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
      end;
    end;
    if (pos < 0) then 
      pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
    end;
    if ((pos > _end) or (pos > self.length)) then 
      do return _hx_tab_array({ }, 0) end;
    end;
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = _end;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      end;
    do return ret end
  end,
  'splice', function(self,pos,len) 
    if ((len < 0) or (pos > self.length)) then 
      do return _hx_tab_array({ }, 0) end;
    else
      if (pos < 0) then 
        pos = self.length - (_G.math.fmod(-pos, self.length));
      end;
    end;
    local b = self.length - pos;
    len = (function() 
      local _hx_1
      if (Math.isNaN(len) or Math.isNaN(b)) then 
      _hx_1 = (0/0); else 
      _hx_1 = _G.math.min(len,b); end
      return _hx_1
    end )();
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = pos + len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      self[i] = self[i + len];
      end;
    local _g11 = pos + len;
    local _g2 = self.length;
    while (_g11 < _g2) do 
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      self[i1] = self[i1 + len];
      end;
    local tmp = self;
    tmp.length = tmp.length - len;
    do return ret end
  end,
  'unshift', function(self,x) 
    local len = self.length;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[len - i] = self[(len - i) - 1];
      end;
    self[0] = x;
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
  ,'__class__',  Array
)

BuildLog.new = function() 
  local self = _hx_new(BuildLog.prototype)
  BuildLog.super(self)
  return self
end
BuildLog.super = function(self) 
  self.list = _hx_tab_array({ }, 0);
  self.nextSegmentId = 0;
  self.curVert = nil;
end
BuildLog.__name__ = true
BuildLog.prototype = _hx_a(
  'push', function(self,type,data) 
    self.list:push(_hx_o({__fields__={type=true,data=true},type=type,data=(function() 
      local _hx_1
      if (data) then 
      _hx_1 = haxe.Json.parse(haxe.Json.stringify(data)); else 
      _hx_1 = nil; end
      return _hx_1
    end )()}));
    do return self end
  end,
  'segmentId', function(self) 
    do return (function() 
    local _hx_obj = self;
    local _hx_fld = 'nextSegmentId';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)() end
  end,
  'checkIntersection', function(self,seg1,seg2) 
    do return self:push("check",_hx_o({__fields__={seg1=true,seg2=true},seg1=seg1,seg2=seg2})) end
  end,
  'segmentChop', function(self,seg,_end) 
    self:push("div_seg",_hx_o({__fields__={seg=true,pt=true},seg=seg,pt=_end}));
    do return self:push("chop",_hx_o({__fields__={seg=true,pt=true},seg=seg,pt=_end})) end
  end,
  'statusRemove', function(self,seg) 
    do return self:push("pop_seg",_hx_o({__fields__={seg=true},seg=seg})) end
  end,
  'segmentUpdate', function(self,seg) 
    do return self:push("seg_update",_hx_o({__fields__={seg=true},seg=seg})) end
  end,
  'segmentNew', function(self,seg,primary) 
    do return self:push("new_seg",_hx_o({__fields__={seg=true,primary=true},seg=seg,primary=primary})) end
  end,
  'segmentRemove', function(self,seg) 
    do return self:push("rem_seg",_hx_o({__fields__={seg=true},seg=seg})) end
  end,
  'tempStatus', function(self,seg,above,below) 
    do return self:push("temp_status",_hx_o({__fields__={seg=true,above=true,below=true},seg=seg,above=above,below=below})) end
  end,
  'rewind', function(self,seg) 
    do return self:push("rewind",_hx_o({__fields__={seg=true},seg=seg})) end
  end,
  'status', function(self,seg,above,below) 
    do return self:push("status",_hx_o({__fields__={seg=true,above=true,below=true},seg=seg,above=above,below=below})) end
  end,
  'vert', function(self,x) 
    if (x == self.curVert) then 
      do return self end;
    end;
    self.curVert = x;
    do return self:push("vert",_hx_o({__fields__={x=true},x=x})) end
  end,
  'log', function(self,data) 
    if (lua.Boot.__instanceof(data,String)) then 
      data = haxe.Json.stringify(data,nil,"  ");
    end;
    do return self:push("log",_hx_o({__fields__={txt=true},txt=data})) end
  end,
  'reset', function(self) 
    do return self:push("reset") end
  end,
  'selected', function(self,segs) 
    do return self:push("selected",_hx_o({__fields__={segs=true},segs=segs})) end
  end,
  'chainStart', function(self,seg) 
    do return self:push("chain_start",_hx_o({__fields__={seg=true},seg=seg})) end
  end,
  'chainRemoveHead', function(self,index,pt) 
    do return self:push("chain_rem_head",_hx_o({__fields__={index=true,pt=true},index=index,pt=pt})) end
  end,
  'chainRemoveTail', function(self,index,pt) 
    do return self:push("chain_rem_tail",_hx_o({__fields__={index=true,pt=true},index=index,pt=pt})) end
  end,
  'chainNew', function(self,pt1,pt2) 
    do return self:push("chain_new",_hx_o({__fields__={pt1=true,pt2=true},pt1=pt1,pt2=pt2})) end
  end,
  'chainMatch', function(self,index) 
    do return self:push("chain_match",_hx_o({__fields__={index=true},index=index})) end
  end,
  'chainClose', function(self,index) 
    do return self:push("chain_close",_hx_o({__fields__={index=true},index=index})) end
  end,
  'chainAddHead', function(self,index,pt) 
    do return self:push("chain_add_head",_hx_o({__fields__={index=true,pt=true},index=index,pt=pt})) end
  end,
  'chainAddTail', function(self,index,pt) 
    do return self:push("chain_add_tail",_hx_o({__fields__={index=true,pt=true},index=index,pt=pt})) end
  end,
  'chainConnect', function(self,index1,index2) 
    do return self:push("chain_con",_hx_o({__fields__={index1=true,index2=true},index1=index1,index2=index2})) end
  end,
  'chainReverse', function(self,index) 
    do return self:push("chain_rev",_hx_o({__fields__={index=true},index=index})) end
  end,
  'chainJoin', function(self,index1,index2) 
    do return self:push("chain_join",_hx_o({__fields__={index1=true,index2=true},index1=index1,index2=index2})) end
  end,
  'done', function(self) 
    do return self:push("done") end
  end
  ,'__class__',  BuildLog
)

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t",self.t);
end
Date.__name__ = true
Date.now = function() 
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t",Std.int(d.t));
  do return d end;
end
Date.fromTime = function(t) 
  local d = _hx_e();
  _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t",Std.int(d.t));
  do return d end;
end
Date.fromString = function(s) 
  do return lua.Boot.strDate(s) end;
end
Date.prototype = _hx_a(
  'getHours', function(self) 
    do return self.d.hour end
  end,
  'getMinutes', function(self) 
    do return self.d.min end
  end,
  'getSeconds', function(self) 
    do return self.d.sec end
  end,
  'getFullYear', function(self) 
    do return self.d.year end
  end,
  'getMonth', function(self) 
    do return self.d.month - 1 end
  end,
  'getDate', function(self) 
    do return self.d.day end
  end
  ,'__class__',  Date
)

Epsilon.new = function(eps) 
  local self = _hx_new(Epsilon.prototype)
  Epsilon.super(self,eps)
  return self
end
Epsilon.super = function(self,eps) 
  if (eps == nil) then 
    eps = 0.0000000001;
  end;
  self.eps = eps;
end
Epsilon.__name__ = true
Epsilon.prototype = _hx_a(
  'epsilon', function(self,v) 
    if (lua.Boot.__instanceof(v,Float)) then 
      self.eps = v;
    end;
    do return self.eps end
  end,
  'pointAboveOrOnLine', function(self,pt,left,right) 
    local Ax = left[0];
    local Ay = left[1];
    local Bx = right[0];
    local By = right[1];
    local Cx = pt[0];
    local Cy = pt[1];
    do return (((Bx - Ax) * (Cy - Ay)) - ((By - Ay) * (Cx - Ax))) >= -self.eps end
  end,
  'pointBetween', function(self,p,left,right) 
    local d_py_ly = p[1] - left[1];
    local d_rx_lx = right[0] - left[0];
    local d_px_lx = p[0] - left[0];
    local d_ry_ly = right[1] - left[1];
    local dot = (d_px_lx * d_rx_lx) + (d_py_ly * d_ry_ly);
    if (dot < self.eps) then 
      do return false end;
    end;
    local sqlen = (d_rx_lx * d_rx_lx) + (d_ry_ly * d_ry_ly);
    if ((dot - sqlen) > -self.eps) then 
      do return false end;
    end;
    do return true end
  end,
  'pointsSameX', function(self,p1,p2) 
    do return _G.math.abs(p1[0] - p2[0]) < self.eps end
  end,
  'pointsSameY', function(self,p1,p2) 
    do return _G.math.abs(p1[1] - p2[1]) < self.eps end
  end,
  'pointsSame', function(self,p1,p2) 
    if (_G.math.abs(p1[0] - p2[0]) < self.eps) then 
      do return _G.math.abs(p1[1] - p2[1]) < self.eps end;
    else
      do return false end;
    end;
  end,
  'pointsCompare', function(self,p1,p2) 
    if (_G.math.abs(p1[0] - p2[0]) < self.eps) then 
      if (_G.math.abs(p1[1] - p2[1]) < self.eps) then 
        do return 0 end;
      else
        if (p1[1] < p2[1]) then 
          do return -1 end;
        else
          do return 1 end;
        end;
      end;
    end;
    if (p1[0] < p2[0]) then 
      do return -1 end;
    else
      do return 1 end;
    end;
  end,
  'pointsCollinear', function(self,pt1,pt2,pt3) 
    local dx1 = pt1[0] - pt2[0];
    local dy1 = pt1[1] - pt2[1];
    local dx2 = pt2[0] - pt3[0];
    local dy2 = pt2[1] - pt3[1];
    do return _G.math.abs((dx1 * dy2) - (dx2 * dy1)) < self.eps end
  end,
  'linesIntersect', function(self,a0,a1,b0,b1) 
    local adx = a1[0] - a0[0];
    local ady = a1[1] - a0[1];
    local bdx = b1[0] - b0[0];
    local bdy = b1[1] - b0[1];
    local axb = (adx * bdy) - (ady * bdx);
    if (_G.math.abs(axb) < self.eps) then 
      do return nil end;
    end;
    local dx = a0[0] - b0[0];
    local dy = a0[1] - b0[1];
    local A = ((bdx * dy) - (bdy * dx)) / axb;
    local B = ((adx * dy) - (ady * dx)) / axb;
    local ret = _hx_o({__fields__={alongA=true,alongB=true,pt=true},alongA=0,alongB=0,pt=_hx_tab_array({[0]=a0[0] + (A * adx), a0[1] + (A * ady) }, 2)});
    if (A <= -self.eps) then 
      ret.alongA = -2;
    else
      if (A < self.eps) then 
        ret.alongA = -1;
      else
        if ((A - 1) <= -self.eps) then 
          ret.alongA = 0;
        else
          if ((A - 1) < self.eps) then 
            ret.alongA = 1;
          else
            ret.alongA = 2;
          end;
        end;
      end;
    end;
    if (B <= -self.eps) then 
      ret.alongB = -2;
    else
      if (B < self.eps) then 
        ret.alongB = -1;
      else
        if ((B - 1) <= -self.eps) then 
          ret.alongB = 0;
        else
          if ((B - 1) < self.eps) then 
            ret.alongB = 1;
          else
            ret.alongB = 2;
          end;
        end;
      end;
    end;
    do return ret end
  end,
  'pointInsideRegion', function(self,pt,region) 
    local x = pt[0];
    local y = pt[1];
    local last_x = region[region.length - 1][0];
    local last_y = region[region.length - 1][1];
    local inside = false;
    local _g1 = 0;
    local _g = region.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local curr_x = region[i][0];
      local curr_y = region[i][1];
      if ((((curr_y - y) > self.eps) ~= ((last_y - y) > self.eps)) and ((((((last_x - curr_x) * (y - curr_y)) / (last_y - curr_y)) + curr_x) - x) > self.eps)) then 
        inside = not inside;
      end;
      last_x = curr_x;
      last_y = curr_y;
      end;
    do return inside end
  end
  ,'__class__',  Epsilon
)

GeoJSON.new = {}
GeoJSON.__name__ = true
GeoJSON.toPolygon = function(polyBool,geojson) 
  local GeoPoly = function(coords) 
    if (coords.length <= 0) then 
      do return polyBool:segments(_hx_o({__fields__={inverted=true,regions=true},inverted=false,regions=_hx_tab_array({ }, 0)})) end;
    end;
    local LineString = function(ls) 
      local reg = ls:slice(0,ls.length - 1);
      do return polyBool:segments(_hx_o({__fields__={inverted=true,regions=true},inverted=false,regions=_hx_tab_array({[0]=reg }, 1)})) end;
    end;
    local out = LineString(coords[0]);
    local _g1 = 1;
    local _g = coords.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local out1 = LineString(coords[i]);
      local out2 = polyBool:combine(out,out1);
      out = polyBool:selectDifference(out2);
      end;
    do return out end;
  end;
  if (geojson.type == "Polygon") then 
    local tmp = GeoPoly(geojson.coordinates);
    do return polyBool:polygon(tmp) end;
  else
    if (geojson.type == "MultiPolygon") then 
      local out3 = polyBool:segments(_hx_o({__fields__={inverted=true,regions=true},inverted=false,regions=_hx_tab_array({ }, 0)}));
      local _g11 = 0;
      local _g2 = geojson.coordinates.length;
      while (_g11 < _g2) do 
        _g11 = _g11 + 1;
        local i1 = _g11 - 1;
        local out4 = GeoPoly(geojson.coordinates[i1]);
        local out5 = polyBool:combine(out3,out4);
        out3 = polyBool:selectUnion(out5);
        end;
      do return polyBool:polygon(out3) end;
    end;
  end;
  _G.error("PolyBool: Cannot convert GeoJSON object to PolyBool polygon",0);
end
GeoJSON.fromPolygon = function(polyBool,eps,poly) 
  poly = polyBool:polygon(polyBool:segments(poly));
  local regionInsideRegion = function(r1,r2) 
    do return eps:pointInsideRegion(_hx_tab_array({[0]=(r1[0][0] + r1[1][0]) * 0.5, (r1[0][1] + r1[1][1]) * 0.5 }, 2),r2) end;
  end;
  local roots = GeoJSONNode.new(nil);
  local addChild = nil;
  addChild = function(root,region) 
    local _g1 = 0;
    local _g = root.children.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local child = root.children[i];
      if (regionInsideRegion(region,child.region)) then 
        addChild(child,region);
        do return end;
      end;
      end;
    local node = GeoJSONNode.new(region);
    local i1 = 0;
    while (i1 < root.children.length) do 
      local child1 = root.children[i1];
      if (regionInsideRegion(child1.region,region)) then 
        node.children:push(child1);
        root.children:splice(i1,1);
      else
        i1 = i1 + 1;
      end;
      end;
    root.children:push(node);
  end;
  local addChild1 = addChild;
  local _g11 = 0;
  local _g2 = poly.regions.length;
  local _hx_break_0 = false;
  while (_g11 < _g2) do 
    repeat 
    _g11 = _g11 + 1;
    local i2 = _g11 - 1;
    local region1 = poly.regions[i2];
    if (region1.length < 3) then 
      break;
    end;
    addChild1(roots,region1);
    
  until true
  if _hx_break_1 then _hx_break_1 = false; break; end
  end;
  local forceWinding = function(region2,clockwise) 
    local winding = .0;
    local last_x = region2[region2.length - 1][0];
    local last_y = region2[region2.length - 1][1];
    local copy = _hx_tab_array({ }, 0);
    local _g12 = 0;
    local _g3 = region2.length;
    while (_g12 < _g3) do 
      _g12 = _g12 + 1;
      local i3 = _g12 - 1;
      local curr_x = region2[i3][0];
      local curr_y = region2[i3][1];
      copy:push(_hx_tab_array({[0]=curr_x, curr_y }, 2));
      winding = winding + ((curr_y * last_x) - (curr_x * last_y));
      last_x = curr_x;
      last_y = curr_y;
      end;
    local isclockwise = winding < 0;
    if (isclockwise ~= clockwise) then 
      copy:reverse();
    end;
    copy:push(_hx_tab_array({[0]=copy[0][0], copy[0][1] }, 2));
    do return copy end;
  end;
  local geopolys = _hx_tab_array({ }, 0);
  local addExterior;
  local getInterior;
  addExterior = function(node1) 
    local poly1 = _hx_tab_array({[0]=forceWinding(node1.region,false) }, 1);
    geopolys:push(poly1);
    local _g13 = 0;
    local _g4 = node1.children.length;
    while (_g13 < _g4) do 
      _g13 = _g13 + 1;
      local i4 = _g13 - 1;
      poly1:push(getInterior(node1.children[i4]));
      end;
  end;
  getInterior = function(node2) 
    local _g14 = 0;
    local _g5 = node2.children.length;
    while (_g14 < _g5) do 
      _g14 = _g14 + 1;
      local i5 = _g14 - 1;
      addExterior(node2.children[i5]);
      end;
    do return forceWinding(node2.region,true) end;
  end;
  local _g15 = 0;
  local _g6 = roots.children.length;
  while (_g15 < _g6) do 
    _g15 = _g15 + 1;
    local i6 = _g15 - 1;
    addExterior(roots.children[i6]);
    end;
  if (geopolys.length <= 0) then 
    do return _hx_o({__fields__={type=true,coordinates=true},type="Polygon",coordinates=_hx_tab_array({ }, 0)}) end;
  end;
  if (geopolys.length == 1) then 
    do return _hx_o({__fields__={type=true,coordinates=true},type="Polygon",coordinates=geopolys[0]}) end;
  end;
  do return _hx_o({__fields__={type=true,coordinates=true},type="MultiPolygon",coordinates=geopolys}) end;
end

GeoJSONNode.new = function(region) 
  local self = _hx_new(GeoJSONNode.prototype)
  GeoJSONNode.super(self,region)
  return self
end
GeoJSONNode.super = function(self,region) 
  self.region = region;
  self.children = _hx_tab_array({ }, 0);
end
GeoJSONNode.__name__ = true
GeoJSONNode.prototype = _hx_a(
  
  '__class__',  GeoJSONNode
)

Intersecter.new = {}
Intersecter.__name__ = true
Intersecter.intersecter = function(selfIntersection,eps,buildLog) 
  local event_root = LinkedList.new();
  local eventCompare = function(p1_isStart,p1_1,p1_2,p2_isStart,p2_1,p2_2) 
    local comp = (function() 
      local _hx_1
      if (_G.math.abs(p1_1[0] - p2_1[0]) < eps.eps) then 
      _hx_1 = (function() 
        local _hx_2
        if (_G.math.abs(p1_1[1] - p2_1[1]) < eps.eps) then 
        _hx_2 = 0; elseif (p1_1[1] < p2_1[1]) then 
        _hx_2 = -1; else 
        _hx_2 = 1; end
        return _hx_2
      end )(); elseif (p1_1[0] < p2_1[0]) then 
      _hx_1 = -1; else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    if (comp ~= 0) then 
      do return comp end;
    end;
    if ((_G.math.abs(p1_2[0] - p2_2[0]) < eps.eps) and (_G.math.abs(p1_2[1] - p2_2[1]) < eps.eps)) then 
      do return 0 end;
    end;
    if (p1_isStart ~= p2_isStart) then 
      if (p1_isStart) then 
        do return 1 end;
      else
        do return -1 end;
      end;
    end;
    local left = (function() 
      local _hx_3
      if (p2_isStart) then 
      _hx_3 = p2_1; else 
      _hx_3 = p2_2; end
      return _hx_3
    end )();
    local right = (function() 
      local _hx_4
      if (p2_isStart) then 
      _hx_4 = p2_2; else 
      _hx_4 = p2_1; end
      return _hx_4
    end )();
    local Ax = left[0];
    local Ay = left[1];
    local Bx = right[0];
    local By = right[1];
    local Cx = p1_2[0];
    local Cy = p1_2[1];
    if ((((Bx - Ax) * (Cy - Ay)) - ((By - Ay) * (Cx - Ax))) >= -eps.eps) then 
      do return 1 end;
    else
      do return -1 end;
    end;
  end;
  local eventAdd = function(ev,other_pt) 
    event_root:insertBefore(ev,function(here) 
      local comp1 = eventCompare(ev.isStart,ev.pt,other_pt,here.isStart,here.pt,here.other.pt);
      do return comp1 < 0 end;
    end);
  end;
  local eventUpdateEnd = function(ev1,_end) 
    if (buildLog ~= nil) then 
      local seg = ev1.seg;
      buildLog:push("div_seg",_hx_o({__fields__={seg=true,pt=true},seg=seg,pt=_end}));
      buildLog:push("chop",_hx_o({__fields__={seg=true,pt=true},seg=seg,pt=_end}));
    end;
    ev1.other:remove();
    ev1.seg["end"] = _end;
    ev1.other.pt = _end;
    eventAdd(ev1.other,ev1.pt);
  end;
  local eventDivide = function(ev2,pt) 
    local seg1 = ev2.seg;
    local ns;
    if (buildLog ~= nil) then 
      ns = (function() 
      local _hx_obj = buildLog;
      local _hx_fld = 'nextSegmentId';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
    else
      ns = -1;
    end;
    local ns1 = _hx_o({__fields__={id=true,start=true,['end']=true,myFill=true,otherFill=true},id=ns,start=pt,['end']=ev2.seg["end"],myFill=_hx_o({__fields__={above=true,below=true},above=seg1.myFill.above,below=seg1.myFill.below}),otherFill=nil});
    eventUpdateEnd(ev2,pt);
    local primary = ev2.primary;
    local ev_start = LinkedList.node(_hx_o({__fields__={isStart=true,pt=true,seg=true,primary=true,other=true,status=true},isStart=true,pt=ns1.start,seg=ns1,primary=primary,other=nil,status=nil}));
    eventAdd(ev_start,ns1["end"]);
    local ev_start1 = ev_start;
    local ev_end = LinkedList.node(_hx_o({__fields__={isStart=true,pt=true,seg=true,primary=true,other=true,status=true},isStart=false,pt=ns1["end"],seg=ns1,primary=primary,other=ev_start1,status=nil}));
    ev_start1.other = ev_end;
    eventAdd(ev_end,ev_start1.pt);
    do return ev_start1 end;
  end;
  local calculate = function(primaryPolyInverted,secondaryPolyInverted) 
    local status_root = LinkedList.new();
    local statusCompare = function(ev11,ev21) 
      local a1 = ev11.seg.start;
      local a2 = ev11.seg["end"];
      local b1 = ev21.seg.start;
      local b2 = ev21.seg["end"];
      local dx1 = a1[0] - b1[0];
      local dy1 = a1[1] - b1[1];
      local dx2 = b1[0] - b2[0];
      local dy2 = b1[1] - b2[1];
      if (_G.math.abs((dx1 * dy2) - (dx2 * dy1)) < eps.eps) then 
        local dx11 = a2[0] - b1[0];
        local dy11 = a2[1] - b1[1];
        local dx21 = b1[0] - b2[0];
        local dy21 = b1[1] - b2[1];
        if (_G.math.abs((dx11 * dy21) - (dx21 * dy11)) < eps.eps) then 
          do return 1 end;
        end;
        local Ax1 = b1[0];
        local Ay1 = b1[1];
        local Bx1 = b2[0];
        local By1 = b2[1];
        local Cx1 = a2[0];
        local Cy1 = a2[1];
        if ((((Bx1 - Ax1) * (Cy1 - Ay1)) - ((By1 - Ay1) * (Cx1 - Ax1))) >= -eps.eps) then 
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
      local Ax2 = b1[0];
      local Ay2 = b1[1];
      local Bx2 = b2[0];
      local By2 = b2[1];
      local Cx2 = a1[0];
      local Cy2 = a1[1];
      if ((((Bx2 - Ax2) * (Cy2 - Ay2)) - ((By2 - Ay2) * (Cx2 - Ax2))) >= -eps.eps) then 
        do return 1 end;
      else
        do return -1 end;
      end;
    end;
    local statusFindSurrounding = function(ev3) 
      do return status_root:findTransition(function(here1) 
        local comp2 = statusCompare(ev3,here1.ev);
        do return comp2 > 0 end;
      end) end;
    end;
    local checkIntersection = function(ev12,ev22) 
      local seg11 = ev12.seg;
      local seg2 = ev22.seg;
      local a11 = seg11.start;
      local a21 = seg11["end"];
      local b11 = seg2.start;
      local b21 = seg2["end"];
      if (buildLog ~= nil) then 
        buildLog:push("check",_hx_o({__fields__={seg1=true,seg2=true},seg1=seg11,seg2=seg2}));
      end;
      local i = eps:linesIntersect(a11,a21,b11,b21);
      if (i == nil) then 
        local dx12 = a11[0] - a21[0];
        local dy12 = a11[1] - a21[1];
        local dx22 = a21[0] - b11[0];
        local dy22 = a21[1] - b11[1];
        if (not (_G.math.abs((dx12 * dy22) - (dx22 * dy12)) < eps.eps)) then 
          do return nil end;
        end;
        if (((_G.math.abs(a11[0] - b21[0]) < eps.eps) and (_G.math.abs(a11[1] - b21[1]) < eps.eps)) or ((_G.math.abs(a21[0] - b11[0]) < eps.eps) and (_G.math.abs(a21[1] - b11[1]) < eps.eps))) then 
          do return nil end;
        end;
        local a1_equ_b1 = (_G.math.abs(a11[0] - b11[0]) < eps.eps) and (_G.math.abs(a11[1] - b11[1]) < eps.eps);
        local a2_equ_b2 = (_G.math.abs(a21[0] - b21[0]) < eps.eps) and (_G.math.abs(a21[1] - b21[1]) < eps.eps);
        if (a1_equ_b1 and a2_equ_b2) then 
          do return ev22 end;
        end;
        local a1_between = not a1_equ_b1 and eps:pointBetween(a11,b11,b21);
        local a2_between = not a2_equ_b2 and eps:pointBetween(a21,b11,b21);
        if (a1_equ_b1) then 
          if (a2_between) then 
            eventDivide(ev22,a21);
          else
            eventDivide(ev12,b21);
          end;
          do return ev22 end;
        else
          if (a1_between) then 
            if (not a2_equ_b2) then 
              if (a2_between) then 
                eventDivide(ev22,a21);
              else
                eventDivide(ev12,b21);
              end;
            end;
            eventDivide(ev22,a11);
          end;
        end;
      else
        if (i.alongA == 0) then 
          if (i.alongB == -1) then 
            eventDivide(ev12,b11);
          else
            if (i.alongB == 0) then 
              eventDivide(ev12,i.pt);
            else
              if (i.alongB == 1) then 
                eventDivide(ev12,b21);
              end;
            end;
          end;
        end;
        if (i.alongB == 0) then 
          if (i.alongA == -1) then 
            eventDivide(ev22,a11);
          else
            if (i.alongA == 0) then 
              eventDivide(ev22,i.pt);
            else
              if (i.alongA == 1) then 
                eventDivide(ev22,a21);
              end;
            end;
          end;
        end;
      end;
      do return nil end;
    end;
    local segments = _hx_tab_array({ }, 0);
    local _hx_break_0 = false;
    while (event_root.root.next ~= nil) do 
      repeat 
      local ev4 = _hx_tab_array({[0]=event_root.root.next }, 1);
      if (buildLog ~= nil) then 
        local x = ev4[0].pt[0];
        if (x ~= buildLog.curVert) then 
          buildLog.curVert = x;
          buildLog:push("vert",_hx_o({__fields__={x=true},x=x}));
        end;
      end;
      if (ev4[0].isStart) then 
        if (buildLog ~= nil) then 
          buildLog:push("new_seg",_hx_o({__fields__={seg=true,primary=true},seg=ev4[0].seg,primary=ev4[0].primary}));
        end;
        local surrounding = statusFindSurrounding(ev4[0]);
        local above = _hx_tab_array({[0]=(function() 
          local _hx_5
          if (surrounding.before ~= nil) then 
          _hx_5 = surrounding.before.ev; else 
          _hx_5 = nil; end
          return _hx_5
        end )() }, 1);
        local below = _hx_tab_array({[0]=(function() 
          local _hx_6
          if (surrounding.after ~= nil) then 
          _hx_6 = surrounding.after.ev; else 
          _hx_6 = nil; end
          return _hx_6
        end )() }, 1);
        if (buildLog ~= nil) then 
          buildLog:push("temp_status",_hx_o({__fields__={seg=true,above=true,below=true},seg=ev4[0].seg,above=above[0] and above[0].seg,below=below[0] and below[0].seg}));
        end;
        local checkBothIntersections = (function(below1,above1,ev5) 
          do return function() 
            if (above1[0]) then 
              local eve = checkIntersection(ev5[0],above1[0]);
              if (eve ~= nil) then 
                do return eve end;
              end;
            end;
            if (below1[0]) then 
              do return checkIntersection(ev5[0],below1[0]) end;
            end;
            do return nil end;
          end end;
        end)(below,above,ev4);
        local eve1 = checkBothIntersections();
        if (eve1 ~= nil) then 
          if (selfIntersection) then 
            local toggle;
            if (ev4[0].seg.myFill.below == nil) then 
              toggle = true;
            else
              toggle = ev4[0].seg.myFill.above ~= ev4[0].seg.myFill.below;
            end;
            if (toggle) then 
              eve1.seg.myFill.above = not eve1.seg.myFill.above;
            end;
          else
            eve1.seg.otherFill = ev4[0].seg.myFill;
          end;
          if (buildLog ~= nil) then 
            buildLog:push("seg_update",_hx_o({__fields__={seg=true},seg=eve1.seg}));
          end;
          ev4[0].other:remove();
          ev4[0]:remove();
        end;
        if (event_root.root.next ~= ev4[0]) then 
          if (buildLog ~= nil) then 
            buildLog:push("rewind",_hx_o({__fields__={seg=true},seg=ev4[0].seg}));
          end;
          break;
        end;
        if (selfIntersection) then 
          local toggle1;
          if (ev4[0].seg.myFill.below == nil) then 
            toggle1 = true;
          else
            toggle1 = ev4[0].seg.myFill.above ~= ev4[0].seg.myFill.below;
          end;
          if (not below[0]) then 
            ev4[0].seg.myFill.below = primaryPolyInverted;
          else
            ev4[0].seg.myFill.below = below[0].seg.myFill.above;
          end;
          if (toggle1) then 
            ev4[0].seg.myFill.above = not ev4[0].seg.myFill.below;
          else
            ev4[0].seg.myFill.above = ev4[0].seg.myFill.below;
          end;
        else
          if (ev4[0].seg.otherFill == nil) then 
            local inside;
            if (not below[0]) then 
              if (ev4[0].primary) then 
                inside = secondaryPolyInverted;
              else
                inside = primaryPolyInverted;
              end;
            else
              if (ev4[0].primary == below[0].primary) then 
                inside = below[0].seg.otherFill.above;
              else
                inside = below[0].seg.myFill.above;
              end;
            end;
            ev4[0].seg.otherFill = _hx_o({__fields__={above=true,below=true},above=inside,below=inside});
          end;
        end;
        if (buildLog ~= nil) then 
          buildLog:push("status",_hx_o({__fields__={seg=true,above=true,below=true},seg=ev4[0].seg,above=above[0] and above[0].seg,below=below[0] and below[0].seg}));
        end;
        local calculate1 = LinkedList.node(_hx_o({__fields__={ev=true},ev=ev4[0]}));
        ev4[0].other.status = surrounding:insert(calculate1);
      else
        local st = ev4[0].status;
        if (st == nil) then 
          _G.error("PolyBool: Zero-length segment detected; your epsilon is " .. "probably too small or too large",0);
        end;
        local calculate2;
        local node = st.prev;
        if ((function() 
          local _hx_7
          if ((node == nil) or (node == status_root.root)) then 
          _hx_7 = false; else 
          _hx_7 = true; end
          return _hx_7
        end )()) then 
          local node1 = st.next;
          if ((node1 == nil) or (node1 == status_root.root)) then 
            calculate2 = false;
          else
            calculate2 = true;
          end;
        else
          calculate2 = false;
        end;
        if (calculate2) then 
          checkIntersection(st.prev.ev,st.next.ev);
        end;
        if (buildLog ~= nil) then 
          buildLog:push("pop_seg",_hx_o({__fields__={seg=true},seg=st.ev.seg}));
        end;
        st:remove();
        if (not ev4[0].primary) then 
          local s = ev4[0].seg.myFill;
          ev4[0].seg.myFill = ev4[0].seg.otherFill;
          ev4[0].seg.otherFill = s;
        end;
        segments:push(ev4[0].seg);
      end;
      event_root.root.next:remove();
      
    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    if (buildLog ~= nil) then 
      buildLog:push("done");
    end;
    do return segments end;
  end;
  if (not selfIntersection) then 
    do return _hx_o({__fields__={calculateNSI=true},calculateNSI=function(self,segments1,inverted1,segments2,inverted2) 
      local _g = 0;
      while (_g < segments1.length) do 
        local seg3 = segments1[_g];
        _g = _g + 1;
        local seg4;
        if (buildLog ~= nil) then 
          seg4 = (function() 
          local _hx_obj = buildLog;
          local _hx_fld = 'nextSegmentId';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
        else
          seg4 = -1;
        end;
        local seg5 = _hx_o({__fields__={id=true,start=true,['end']=true,myFill=true,otherFill=true},id=seg4,start=seg3.start,['end']=seg3["end"],myFill=_hx_o({__fields__={above=true,below=true},above=seg3.myFill.above,below=seg3.myFill.below}),otherFill=nil});
        local ev_start2 = LinkedList.node(_hx_o({__fields__={isStart=true,pt=true,seg=true,primary=true,other=true,status=true},isStart=true,pt=seg5.start,seg=seg5,primary=true,other=nil,status=nil}));
        eventAdd(ev_start2,seg5["end"]);
        local ev_start3 = ev_start2;
        local ev_end1 = LinkedList.node(_hx_o({__fields__={isStart=true,pt=true,seg=true,primary=true,other=true,status=true},isStart=false,pt=seg5["end"],seg=seg5,primary=true,other=ev_start3,status=nil}));
        ev_start3.other = ev_end1;
        eventAdd(ev_end1,ev_start3.pt);
        end;
      local _g1 = 0;
      while (_g1 < segments2.length) do 
        local seg6 = segments2[_g1];
        _g1 = _g1 + 1;
        local seg7;
        if (buildLog ~= nil) then 
          seg7 = (function() 
          local _hx_obj = buildLog;
          local _hx_fld = 'nextSegmentId';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
        else
          seg7 = -1;
        end;
        local seg8 = _hx_o({__fields__={id=true,start=true,['end']=true,myFill=true,otherFill=true},id=seg7,start=seg6.start,['end']=seg6["end"],myFill=_hx_o({__fields__={above=true,below=true},above=seg6.myFill.above,below=seg6.myFill.below}),otherFill=nil});
        local ev_start4 = LinkedList.node(_hx_o({__fields__={isStart=true,pt=true,seg=true,primary=true,other=true,status=true},isStart=true,pt=seg8.start,seg=seg8,primary=false,other=nil,status=nil}));
        eventAdd(ev_start4,seg8["end"]);
        local ev_start5 = ev_start4;
        local ev_end2 = LinkedList.node(_hx_o({__fields__={isStart=true,pt=true,seg=true,primary=true,other=true,status=true},isStart=false,pt=seg8["end"],seg=seg8,primary=false,other=ev_start5,status=nil}));
        ev_start5.other = ev_end2;
        eventAdd(ev_end2,ev_start5.pt);
        end;
      do return calculate(inverted1,inverted2) end;
    end}) end;
  end;
  do return _hx_o({__fields__={addRegion=true,calculateSI=true},addRegion=function(self,region) 
    local pt1;
    local pt2 = region[region.length - 1];
    local _g11 = 0;
    local _g2 = region.length;
    local _hx_break_0 = false;
    while (_g11 < _g2) do 
      repeat 
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      pt1 = pt2;
      pt2 = region[i1];
      local forward = (function() 
        local _hx_8
        if (_G.math.abs(pt1[0] - pt2[0]) < eps.eps) then 
        _hx_8 = (function() 
          local _hx_9
          if (_G.math.abs(pt1[1] - pt2[1]) < eps.eps) then 
          _hx_9 = 0; elseif (pt1[1] < pt2[1]) then 
          _hx_9 = -1; else 
          _hx_9 = 1; end
          return _hx_9
        end )(); elseif (pt1[0] < pt2[0]) then 
        _hx_8 = -1; else 
        _hx_8 = 1; end
        return _hx_8
      end )();
      if (forward == 0) then 
        break;
      end;
      local seg9;
      if (buildLog ~= nil) then 
        seg9 = (function() 
        local _hx_obj = buildLog;
        local _hx_fld = 'nextSegmentId';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
      else
        seg9 = -1;
      end;
      local seg10 = _hx_o({__fields__={id=true,start=true,['end']=true,myFill=true,otherFill=true},id=seg9,start=(function() 
        local _hx_10
        if (forward < 0) then 
        _hx_10 = pt1; else 
        _hx_10 = pt2; end
        return _hx_10
      end )(),['end']=(function() 
        local _hx_11
        if (forward < 0) then 
        _hx_11 = pt2; else 
        _hx_11 = pt1; end
        return _hx_11
      end )(),myFill=_hx_o({__fields__={above=true,below=true},above=nil,below=nil}),otherFill=nil});
      local ev_start6 = LinkedList.node(_hx_o({__fields__={isStart=true,pt=true,seg=true,primary=true,other=true,status=true},isStart=true,pt=seg10.start,seg=seg10,primary=true,other=nil,status=nil}));
      eventAdd(ev_start6,seg10["end"]);
      local ev_start7 = ev_start6;
      local ev_end3 = LinkedList.node(_hx_o({__fields__={isStart=true,pt=true,seg=true,primary=true,other=true,status=true},isStart=false,pt=seg10["end"],seg=seg10,primary=true,other=ev_start7,status=nil}));
      ev_start7.other = ev_end3;
      eventAdd(ev_end3,ev_start7.pt);
      
    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
  end,calculateSI=function(self,inverted) 
    do return calculate(inverted,false) end;
  end}) end;
end

LinkedList.new = function() 
  local self = _hx_new(LinkedList.prototype)
  LinkedList.super(self)
  return self
end
LinkedList.super = function(self) 
  self.root = _hx_o({__fields__={root=true,next=true},root=true,next=nil});
end
LinkedList.__name__ = true
LinkedList.node = function(data) 
  data.prev = nil;
  data.next = nil;
  data.remove = function() 
    data.prev.next = data.next;
    if (data.next ~= nil) then 
      data.next.prev = data.prev;
    end;
    data.prev = nil;
    data.next = nil;
  end;
  do return data end;
end
LinkedList.prototype = _hx_a(
  'exists', function(self,node) 
    if ((node == nil) or (node == self.root)) then 
      do return false end;
    end;
    do return true end
  end,
  'isEmpty', function(self) 
    do return self.root.next == nil end
  end,
  'getHead', function(self) 
    do return self.root.next end
  end,
  'insertBefore', function(self,node,check) 
    local last = self.root;
    local here = self.root.next;
    while (here ~= nil) do 
      if (check(here)) then 
        node.prev = here.prev;
        node.next = here;
        here.prev.next = node;
        here.prev = node;
        do return end;
      end;
      last = here;
      here = here.next;
      end;
    last.next = node;
    node.prev = last;
    node.next = nil;
  end,
  'findTransition', function(self,check) 
    local prev = self.root;
    local here = self.root.next;
    while (here ~= nil) do 
      if (check(here)) then 
        break;
      end;
      prev = here;
      here = here.next;
      end;
    do return _hx_o({__fields__={before=true,after=true,insert=true},before=(function() 
      local _hx_1
      if (prev == self.root) then 
      _hx_1 = nil; else 
      _hx_1 = prev; end
      return _hx_1
    end )(),after=here,insert=function(self,node) 
      node.prev = prev;
      node.next = here;
      prev.next = node;
      if (here ~= nil) then 
        here.prev = node;
      end;
      do return node end;
    end}) end
  end
  ,'__class__',  LinkedList
)

Main.new = {}
Main.__name__ = true
Main.nextDemo = function(poly1,poly2) 
  local polyBox_min;
  local polyBox_max;
  polyBox_min = _hx_tab_array({[0]=nil, nil }, 2);
  polyBox_max = _hx_tab_array({[0]=nil, nil }, 2);
  local calcBox = function(regions) 
    local _g1 = 0;
    local _g = regions.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local r = _g1 - 1;
      local region = regions[r];
      local _g3 = 0;
      local _g2 = region.length;
      while (_g3 < _g2) do 
        _g3 = _g3 + 1;
        local p = _g3 - 1;
        local pt = region[p];
        if ((polyBox_min[0] == nil) or (pt[0] < polyBox_min[0])) then 
          polyBox_min[0] = pt[0];
        end;
        if ((polyBox_min[1] == nil) or (pt[1] < polyBox_min[1])) then 
          polyBox_min[1] = pt[1];
        end;
        if ((polyBox_max[0] == nil) or (pt[0] > polyBox_max[0])) then 
          polyBox_max[0] = pt[0];
        end;
        if ((polyBox_max[1] == nil) or (pt[1] > polyBox_max[1])) then 
          polyBox_max[1] = pt[1];
        end;
        end;
      end;
  end;
  calcBox(poly1.regions);
  calcBox(poly2.regions);
  do return _hx_tab_array({[0]=poly1, poly2 }, 2) end;
end
Main.recalc = function(func,polys) 
  local BL = PolyBool.get_instance():buildLog(true);
  local clipResult_result = func(polys[0],polys[1]);
  local clipResult_build_log = BL;
  local geojson = PolyBool.get_instance():polygonToGeoJSON(clipResult_result);
  local scalePoly = function(p) 
    local _g1 = 0;
    local _g = p.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local _g3 = 0;
      local _g2 = p[i].length;
      while (_g3 < _g2) do 
        _g3 = _g3 + 1;
        local j = _g3 - 1;
        p[i][j] = _hx_tab_array({[0]=p[i][j][0] * 0.1, p[i][j][1] * 0.1 }, 2);
        end;
      end;
  end;
  local out = _hx_tab_array({[0]="{", "\"type\":" .. haxe.Json.stringify(geojson.type) .. "," }, 2);
  local outLine = function(line,tail) 
    local o = "[";
    local _g11 = 0;
    local _g4 = line.length;
    while (_g11 < _g4) do 
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      local p1 = line[i1];
      o = o .. ("[" .. p1[0] .. "," .. p1[1] .. "]");
      if (i1 < (line.length - 1)) then 
        o = o .. ",";
      end;
      end;
    out:push(o .. "]" .. ((function() 
      local _hx_1
      if (tail) then 
      _hx_1 = ""; else 
      _hx_1 = ","; end
      return _hx_1
    end )()));
  end;
  if (geojson.type == "Polygon") then 
    local coordinates = geojson.coordinates;
    scalePoly(coordinates);
    out:push("\"coordinates\":[");
    local _g12 = 0;
    local _g5 = coordinates.length;
    while (_g12 < _g5) do 
      _g12 = _g12 + 1;
      local i2 = _g12 - 1;
      outLine(coordinates[i2],i2 == (coordinates.length - 1));
      end;
    out:push("]");
  else
    local coordinates1 = geojson.coordinates;
    local _g13 = 0;
    local _g6 = coordinates1.length;
    while (_g13 < _g6) do 
      _g13 = _g13 + 1;
      local i3 = _g13 - 1;
      scalePoly(coordinates1[i3]);
      end;
    out:push("\"coordinates\":[[");
    local _g14 = 0;
    local _g7 = coordinates1.length;
    while (_g14 < _g7) do 
      _g14 = _g14 + 1;
      local i4 = _g14 - 1;
      local _g31 = 0;
      local _g21 = coordinates1[i4].length;
      while (_g31 < _g21) do 
        _g31 = _g31 + 1;
        local j1 = _g31 - 1;
        outLine(coordinates1[i4][j1],j1 == (coordinates1[i4].length - 1));
        end;
      if (i4 < (coordinates1.length - 1)) then 
        out:push("],[");
      end;
      end;
    out:push("]]");
  end;
  out:push("}");
  do return haxe.Json.parse(out:join("")) end;
end
Main.main = function() 
  local dir = _G.arg[0];
  dir = string.gsub(dir, '/[^/]+$', '');
  local expectedCases = haxe.Json.parse(sys.io.File.getContent(dir .. "/testdata.json"));
  local _g = haxe.ds.StringMap.new();
  local value = (function() local __=PolyBool.get_instance(); return _hx_bind(__,__.intersect) end)();
  _g.v["intersect"] = value;
  _g.k["intersect"] = true;
  local value1 = (function() local __=PolyBool.get_instance(); return _hx_bind(__,__.union) end)();
  _g.v["union"] = value1;
  _g.k["union"] = true;
  local value2 = (function() local __=PolyBool.get_instance(); return _hx_bind(__,__.difference) end)();
  _g.v["difference"] = value2;
  _g.k["difference"] = true;
  local value3 = (function() local __=PolyBool.get_instance(); return _hx_bind(__,__.differenceRev) end)();
  _g.v["differenceRev"] = value3;
  _g.k["differenceRev"] = true;
  local value4 = (function() local __=PolyBool.get_instance(); return _hx_bind(__,__.xor) end)();
  _g.v["xor"] = value4;
  _g.k["xor"] = true;
  local funcs = _g;
  local oks = 0;
  local ngs = 0;
  local _g1 = 0;
  while (_g1 < expectedCases.length) do 
    local expectedCase = expectedCases[_g1];
    _g1 = _g1 + 1;
    local polys = Main.nextDemo(expectedCase.poly1,expectedCase.poly2);
    local _g2 = 0;
    local _g3 = expectedCase.tests;
    while (_g2 < _g3.length) do 
      local expectedTest = _g3[_g2];
      _g2 = _g2 + 1;
      polys[0].inverted = expectedTest.poly1Inverted;
      polys[1].inverted = expectedTest.poly2Inverted;
      local key = expectedTest.operation;
      local actual = Main.recalc(funcs.v[key],polys);
      local expected = expectedTest.result;
      local actualJson = haxe.Json.stringify(actual);
      local expectedJson = haxe.Json.stringify(expected);
      if (actualJson == expectedJson) then 
        oks = oks + 1;
      else
        ngs = ngs + 1;
        haxe.Log.trace("NG: " .. expectedTest.operation,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Main.hx",lineNumber=144,className="Main",methodName="main"}));
        haxe.Log.trace("actual  : " .. actualJson,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Main.hx",lineNumber=145,className="Main",methodName="main"}));
        haxe.Log.trace("expected: " .. expectedJson,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Main.hx",lineNumber=146,className="Main",methodName="main"}));
      end;
      end;
    end;
  haxe.Log.trace("===========================",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Main.hx",lineNumber=150,className="Main",methodName="main"}));
  haxe.Log.trace("OK: " .. oks,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Main.hx",lineNumber=151,className="Main",methodName="main"}));
  haxe.Log.trace("NG: " .. ngs,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Main.hx",lineNumber=152,className="Main",methodName="main"}));
end

Math.new = {}
Math.__name__ = true
Math.isNaN = function(f) 
  do return f ~= f end;
end

PolyBool.new = function() 
  local self = _hx_new(PolyBool.prototype)
  PolyBool.super(self)
  return self
end
PolyBool.super = function(self) 
  self._epsilon = Epsilon.new();
end
PolyBool.__name__ = true
PolyBool.get_instance = function() 
  if (PolyBool._instance == nil) then 
    PolyBool._instance = PolyBool.new();
  end;
  do return PolyBool._instance end;
end
PolyBool.prototype = _hx_a(
  'buildLog', function(self,bl) 
    if (bl) then 
      self._buildLog = BuildLog.new();
    else
      self._buildLog = nil;
    end;
    if (self._buildLog == nil) then 
      do return nil end;
    else
      do return self._buildLog.list end;
    end;
  end,
  'epsilon', function(self,v) 
    local _this = self._epsilon;
    if (lua.Boot.__instanceof(v,Float)) then 
      _this.eps = v;
    end;
    do return _this.eps end
  end,
  'segments', function(self,poly) 
    local i = Intersecter.intersecter(true,self._epsilon,self._buildLog);
    local _g = 0;
    local _g1 = poly.regions;
    while (_g < _g1.length) do 
      local region = _g1[_g];
      _g = _g + 1;
      i:addRegion(region);
      end;
    do return _hx_o({__fields__={segments=true,inverted=true},segments=i:calculateSI(poly.inverted),inverted=poly.inverted}) end
  end,
  'combine', function(self,segments1,segments2) 
    local i3 = Intersecter.intersecter(false,self._epsilon,self._buildLog);
    do return _hx_o({__fields__={combined=true,inverted1=true,inverted2=true},combined=i3:calculateNSI(segments1.segments,segments1.inverted,segments2.segments,segments2.inverted),inverted1=segments1.inverted,inverted2=segments2.inverted}) end
  end,
  'selectUnion', function(self,combined) 
    do return _hx_o({__fields__={segments=true,inverted=true},segments=SegmentSelector.union(combined.combined,self._buildLog),inverted=combined.inverted1 or combined.inverted2}) end
  end,
  'selectIntersect', function(self,combined) 
    do return _hx_o({__fields__={segments=true,inverted=true},segments=SegmentSelector.intersect(combined.combined,self._buildLog),inverted=combined.inverted1 and combined.inverted2}) end
  end,
  'selectDifference', function(self,combined) 
    do return _hx_o({__fields__={segments=true,inverted=true},segments=SegmentSelector.difference(combined.combined,self._buildLog),inverted=combined.inverted1 and not combined.inverted2}) end
  end,
  'selectDifferenceRev', function(self,combined) 
    do return _hx_o({__fields__={segments=true,inverted=true},segments=SegmentSelector.differenceRev(combined.combined,self._buildLog),inverted=not combined.inverted1 and combined.inverted2}) end
  end,
  'selectXor', function(self,combined) 
    do return _hx_o({__fields__={segments=true,inverted=true},segments=SegmentSelector.xor(combined.combined,self._buildLog),inverted=combined.inverted1 ~= combined.inverted2}) end
  end,
  'polygon', function(self,segments) 
    do return _hx_o({__fields__={regions=true,inverted=true},regions=SegmentChainer.segmentChainer(segments.segments,self._epsilon,self._buildLog),inverted=segments.inverted}) end
  end,
  'polygonFromGeoJSON', function(self,geojson) 
    do return GeoJSON.toPolygon(PolyBool.get_instance(),geojson) end
  end,
  'polygonToGeoJSON', function(self,poly) 
    do return GeoJSON.fromPolygon(PolyBool.get_instance(),self._epsilon,poly) end
  end,
  'union', function(self,poly1,poly2) 
    do return self:operate(poly1,poly2,_hx_bind(self,self.selectUnion)) end
  end,
  'intersect', function(self,poly1,poly2) 
    do return self:operate(poly1,poly2,_hx_bind(self,self.selectIntersect)) end
  end,
  'difference', function(self,poly1,poly2) 
    do return self:operate(poly1,poly2,_hx_bind(self,self.selectDifference)) end
  end,
  'differenceRev', function(self,poly1,poly2) 
    do return self:operate(poly1,poly2,_hx_bind(self,self.selectDifferenceRev)) end
  end,
  'xor', function(self,poly1,poly2) 
    do return self:operate(poly1,poly2,_hx_bind(self,self.selectXor)) end
  end,
  'operate', function(self,poly1,poly2,selector) 
    local seg1 = self:segments(poly1);
    local seg2 = self:segments(poly2);
    local comb = self:combine(seg1,seg2);
    local seg3 = selector(comb);
    do return self:polygon(seg3) end
  end
  ,'__class__',  PolyBool
)

Reflect.new = {}
Reflect.__name__ = true
Reflect.field = function(o,field) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      do return o[field] end;
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    local e = _hx_1
    do return nil end;
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
Reflect.fields = function(o) 
  local _g = _hx_tab_array({ }, 0);
  local f = lua.Boot.fieldIterator(o);
  while (f:hasNext()) do 
    local f1 = f:next();
    _g:push(f1);
    end;
  do return _g end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end

SegmentChainer.new = {}
SegmentChainer.__name__ = true
SegmentChainer.segmentChainer = function(segments,eps,buildLog) 
  local chains = _hx_tab_array({ }, 0);
  local regions = _hx_tab_array({ }, 0);
  local _g = 0;
  local _hx_break_0 = false;
  while (_g < segments.length) do 
    repeat 
    local seg = segments[_g];
    _g = _g + 1;
    local pt1 = seg.start;
    local pt2 = seg["end"];
    if ((_G.math.abs(pt1[0] - pt2[0]) < eps.eps) and (_G.math.abs(pt1[1] - pt2[1]) < eps.eps)) then 
      haxe.Log.trace("PolyBool: Warning: Zero-length segment detected; your epsilon is " .. "probably too small or too large",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="SegmentChainer.hx",lineNumber=25,className="SegmentChainer",methodName="segmentChainer"}));
      break;
    end;
    if (buildLog ~= nil) then 
      buildLog:push("chain_start",_hx_o({__fields__={seg=true},seg=seg}));
    end;
    local first_match = _hx_tab_array({[0]=_hx_o({__fields__={index=true,matches_head=true,matches_pt1=true},index=0,matches_head=false,matches_pt1=false}) }, 1);
    local second_match = _hx_tab_array({[0]=_hx_o({__fields__={index=true,matches_head=true,matches_pt1=true},index=0,matches_head=false,matches_pt1=false}) }, 1);
    local next_match = _hx_tab_array({[0]=first_match[0] }, 1);
    local setMatch = (function(next_match1,second_match1,first_match1) 
      do return function(index,matches_head,matches_pt1) 
        next_match1[0].index = index;
        next_match1[0].matches_head = matches_head;
        next_match1[0].matches_pt1 = matches_pt1;
        if (next_match1[0] == first_match1[0]) then 
          next_match1[0] = second_match1[0];
          do return false end;
        end;
        next_match1[0] = nil;
        do return true end;
      end end;
    end)(next_match,second_match,first_match);
    local _g2 = 0;
    local _g1 = chains.length;
    while (_g2 < _g1) do 
      _g2 = _g2 + 1;
      local i = _g2 - 1;
      local chain = chains[i];
      local head = chain[0];
      local head2 = chain[1];
      local tail = chain[chain.length - 1];
      local tail2 = chain[chain.length - 2];
      if ((_G.math.abs(head[0] - pt1[0]) < eps.eps) and (_G.math.abs(head[1] - pt1[1]) < eps.eps)) then 
        if (setMatch(i,true,true)) then 
          break;
        end;
      else
        if ((_G.math.abs(head[0] - pt2[0]) < eps.eps) and (_G.math.abs(head[1] - pt2[1]) < eps.eps)) then 
          if (setMatch(i,true,false)) then 
            break;
          end;
        else
          if ((_G.math.abs(tail[0] - pt1[0]) < eps.eps) and (_G.math.abs(tail[1] - pt1[1]) < eps.eps)) then 
            if (setMatch(i,false,true)) then 
              break;
            end;
          else
            if ((_G.math.abs(tail[0] - pt2[0]) < eps.eps) and (_G.math.abs(tail[1] - pt2[1]) < eps.eps)) then 
              if (setMatch(i,false,false)) then 
                break;
              end;
            end;
          end;
        end;
      end;
      end;
    if (next_match[0] == first_match[0]) then 
      chains:push(_hx_tab_array({[0]=pt1, pt2 }, 2));
      if (buildLog ~= nil) then 
        buildLog:push("chain_new",_hx_o({__fields__={pt1=true,pt2=true},pt1=pt1,pt2=pt2}));
      end;
      break;
    end;
    if (next_match[0] == second_match[0]) then 
      if (buildLog ~= nil) then 
        buildLog:push("chain_match",_hx_o({__fields__={index=true},index=first_match[0].index}));
      end;
      local index1 = first_match[0].index;
      local pt = (function() 
        local _hx_1
        if (first_match[0].matches_pt1) then 
        _hx_1 = pt2; else 
        _hx_1 = pt1; end
        return _hx_1
      end )();
      local addToHead = first_match[0].matches_head;
      local chain1 = chains[index1];
      local grow = (function() 
        local _hx_2
        if (addToHead) then 
        _hx_2 = chain1[0]; else 
        _hx_2 = chain1[chain1.length - 1]; end
        return _hx_2
      end )();
      local grow2 = (function() 
        local _hx_3
        if (addToHead) then 
        _hx_3 = chain1[1]; else 
        _hx_3 = chain1[chain1.length - 2]; end
        return _hx_3
      end )();
      local oppo = (function() 
        local _hx_4
        if (addToHead) then 
        _hx_4 = chain1[chain1.length - 1]; else 
        _hx_4 = chain1[0]; end
        return _hx_4
      end )();
      local oppo2 = (function() 
        local _hx_5
        if (addToHead) then 
        _hx_5 = chain1[chain1.length - 2]; else 
        _hx_5 = chain1[1]; end
        return _hx_5
      end )();
      local dx1 = grow2[0] - grow[0];
      local dy1 = grow2[1] - grow[1];
      local dx2 = grow[0] - pt[0];
      local dy2 = grow[1] - pt[1];
      if (_G.math.abs((dx1 * dy2) - (dx2 * dy1)) < eps.eps) then 
        if (addToHead) then 
          if (buildLog ~= nil) then 
            buildLog:push("chain_rem_head",_hx_o({__fields__={index=true,pt=true},index=first_match[0].index,pt=pt}));
          end;
          chain1:shift();
        else
          if (buildLog ~= nil) then 
            buildLog:push("chain_rem_tail",_hx_o({__fields__={index=true,pt=true},index=first_match[0].index,pt=pt}));
          end;
          chain1:pop();
        end;
        grow = grow2;
      end;
      if ((_G.math.abs(oppo[0] - pt[0]) < eps.eps) and (_G.math.abs(oppo[1] - pt[1]) < eps.eps)) then 
        chains:splice(index1,1);
        local dx11 = oppo2[0] - oppo[0];
        local dy11 = oppo2[1] - oppo[1];
        local dx21 = oppo[0] - grow[0];
        local dy21 = oppo[1] - grow[1];
        if (_G.math.abs((dx11 * dy21) - (dx21 * dy11)) < eps.eps) then 
          if (addToHead) then 
            if (buildLog ~= nil) then 
              buildLog:push("chain_rem_tail",_hx_o({__fields__={index=true,pt=true},index=first_match[0].index,pt=grow}));
            end;
            chain1:pop();
          else
            if (buildLog ~= nil) then 
              buildLog:push("chain_rem_head",_hx_o({__fields__={index=true,pt=true},index=first_match[0].index,pt=grow}));
            end;
            chain1:shift();
          end;
        end;
        if (buildLog ~= nil) then 
          buildLog:push("chain_close",_hx_o({__fields__={index=true},index=first_match[0].index}));
        end;
        regions:push(chain1);
        break;
      end;
      if (addToHead) then 
        if (buildLog ~= nil) then 
          buildLog:push("chain_add_head",_hx_o({__fields__={index=true,pt=true},index=first_match[0].index,pt=pt}));
        end;
        chain1:unshift(pt);
      else
        if (buildLog ~= nil) then 
          buildLog:push("chain_add_tail",_hx_o({__fields__={index=true,pt=true},index=first_match[0].index,pt=pt}));
        end;
        chain1:push(pt);
      end;
      break;
    end;
    local reverseChain = (function() 
      do return function(index2) 
        if (buildLog ~= nil) then 
          buildLog:push("chain_rev",_hx_o({__fields__={index=true},index=index2}));
        end;
        chains[index2]:reverse();
      end end;
    end)();
    local appendChain = (function() 
      do return function(index11,index21) 
        local chain11 = chains[index11];
        local chain2 = chains[index21];
        local tail1 = chain11[chain11.length - 1];
        local tail21 = chain11[chain11.length - 2];
        local head1 = chain2[0];
        local head21 = chain2[1];
        local dx12 = tail21[0] - tail1[0];
        local dy12 = tail21[1] - tail1[1];
        local dx22 = tail1[0] - head1[0];
        local dy22 = tail1[1] - head1[1];
        if (_G.math.abs((dx12 * dy22) - (dx22 * dy12)) < eps.eps) then 
          if (buildLog ~= nil) then 
            buildLog:push("chain_rem_tail",_hx_o({__fields__={index=true,pt=true},index=index11,pt=tail1}));
          end;
          chain11:pop();
          tail1 = tail21;
        end;
        local dx13 = tail1[0] - head1[0];
        local dy13 = tail1[1] - head1[1];
        local dx23 = head1[0] - head21[0];
        local dy23 = head1[1] - head21[1];
        if (_G.math.abs((dx13 * dy23) - (dx23 * dy13)) < eps.eps) then 
          if (buildLog ~= nil) then 
            buildLog:push("chain_rem_head",_hx_o({__fields__={index=true,pt=true},index=index21,pt=head1}));
          end;
          chain2:shift();
        end;
        if (buildLog ~= nil) then 
          buildLog:push("chain_join",_hx_o({__fields__={index1=true,index2=true},index1=index11,index2=index21}));
        end;
        local appendChain1 = chain11:concat(chain2);
        chains[index11] = appendChain1;
        chains:splice(index21,1);
      end end;
    end)();
    local F = first_match[0].index;
    local S = second_match[0].index;
    if (buildLog ~= nil) then 
      buildLog:push("chain_con",_hx_o({__fields__={index1=true,index2=true},index1=F,index2=S}));
    end;
    local reverseF = chains[F].length < chains[S].length;
    if (first_match[0].matches_head) then 
      if (second_match[0].matches_head) then 
        if (reverseF) then 
          reverseChain(F);
          appendChain(F,S);
        else
          reverseChain(S);
          appendChain(S,F);
        end;
      else
        appendChain(S,F);
      end;
    else
      if (second_match[0].matches_head) then 
        appendChain(F,S);
      else
        if (reverseF) then 
          reverseChain(F);
          appendChain(S,F);
        else
          reverseChain(S);
          appendChain(F,S);
        end;
      end;
    end;
    
  until true
  if _hx_break_1 then _hx_break_1 = false; break; end
  end;
  do return regions end;
end

SegmentSelector.new = {}
SegmentSelector.__name__ = true
SegmentSelector.select = function(segments,selection,buildLog) 
  local result = _hx_tab_array({ }, 0);
  local _g = 0;
  while (_g < segments.length) do 
    local seg = segments[_g];
    _g = _g + 1;
    local index = (((function() 
      local _hx_1
      if (seg.myFill.above) then 
      _hx_1 = 8; else 
      _hx_1 = 0; end
      return _hx_1
    end )() + (function() 
      local _hx_2
      if (seg.myFill.below) then 
      _hx_2 = 4; else 
      _hx_2 = 0; end
      return _hx_2
    end )()) + (function() 
      local _hx_3
      if ((seg.otherFill ~= nil) and seg.otherFill.above) then 
      _hx_3 = 2; else 
      _hx_3 = 0; end
      return _hx_3
    end )()) + (function() 
      local _hx_4
      if ((seg.otherFill ~= nil) and seg.otherFill.below) then 
      _hx_4 = 1; else 
      _hx_4 = 0; end
      return _hx_4
    end )();
    if (selection[index] ~= 0) then 
      local tmp;
      if (buildLog ~= nil) then 
        tmp = (function() 
        local _hx_obj = buildLog;
        local _hx_fld = 'nextSegmentId';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
      else
        tmp = -1;
      end;
      result:push(_hx_o({__fields__={id=true,start=true,['end']=true,myFill=true,otherFill=true},id=tmp,start=seg.start,['end']=seg["end"],myFill=_hx_o({__fields__={above=true,below=true},above=selection[index] == 1,below=selection[index] == 2}),otherFill=nil}));
    end;
    end;
  if (buildLog ~= nil) then 
    buildLog:push("selected",_hx_o({__fields__={segs=true},segs=result}));
  end;
  do return result end;
end
SegmentSelector.union = function(segments,buildLog) 
  do return SegmentSelector.select(segments,_hx_tab_array({[0]=0, 2, 1, 0, 2, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0 }, 16),buildLog) end;
end
SegmentSelector.intersect = function(segments,buildLog) 
  do return SegmentSelector.select(segments,_hx_tab_array({[0]=0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 1, 1, 0, 2, 1, 0 }, 16),buildLog) end;
end
SegmentSelector.difference = function(segments,buildLog) 
  do return SegmentSelector.select(segments,_hx_tab_array({[0]=0, 0, 0, 0, 2, 0, 2, 0, 1, 1, 0, 0, 0, 1, 2, 0 }, 16),buildLog) end;
end
SegmentSelector.differenceRev = function(segments,buildLog) 
  do return SegmentSelector.select(segments,_hx_tab_array({[0]=0, 2, 1, 0, 0, 0, 1, 1, 0, 2, 0, 2, 0, 0, 0, 0 }, 16),buildLog) end;
end
SegmentSelector.xor = function(segments,buildLog) 
  do return SegmentSelector.select(segments,_hx_tab_array({[0]=0, 2, 1, 0, 2, 0, 0, 1, 1, 0, 0, 2, 0, 1, 2, 0 }, 16),buildLog) end;
end

String.new = {}
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'split', function(self,delimiter) 
    local idx = 1;
    local ret = _hx_tab_array({ }, 0);
    local delim_offset = (function() 
      local _hx_1
      if (delimiter.length > 0) then 
      _hx_1 = delimiter.length; else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (delimiter.length > 0) then 
        newidx = _G.string.find(self,delimiter,idx,true);
      else
        if (idx >= self.length) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(self,idx,newidx - 1);
        ret:push(match);
        idx = newidx + delimiter.length;
      else
        ret:push(_G.string.sub(self,idx,_G.string.len(self)));
        idx = nil;
      end;
      end;
    do return ret end
  end,
  'toString', function(self) 
    do return self end
  end,
  'substr', function(self,pos,len) 
    if ((len == nil) or (len > (pos + self.length))) then 
      len = self.length;
    else
      if (len < 0) then 
        len = self.length + len;
      end;
    end;
    if (pos < 0) then 
      pos = self.length + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(self,pos + 1,pos + len) end
  end
  ,'__class__',  String
)

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.int = function(x) 
  if (not ((x > -_G.math.huge) and (x < _G.math.huge)) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x,"^ *[%-+]*0[xX][%da-FA-F]*");
  if (hexMatch ~= nil) then 
    do return _G.tonumber(hexMatch:substr(2),16) end;
  else
    local intMatch = _G.string.match(x,"^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x,"^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  x = x:substr(digitMatch.length);
  local decimalMatch = _G.string.match(x,"^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  x = x:substr(decimalMatch.length);
  local eMatch = _G.string.match(x,"^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(digitMatch .. decimalMatch .. eMatch);
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = _hx_e();
  self.length = 0;
end
StringBuf.__name__ = true
StringBuf.prototype = _hx_a(
  
  '__class__',  StringBuf
)

StringTools.new = {}
StringTools.__name__ = true
StringTools.lpad = function(s,c,l) 
  if (c.length <= 0) then 
    do return s end;
  end;
  while (s.length < l) do 
    s = c .. s;
    end;
  do return s end;
end
_hxClasses["ValueType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)


Type.new = {}
Type.__name__ = true
Type.typeof = function(v) 
  local _g = _G.type(v);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g1) == "function" then 
    if ((function() 
      local _hx_1
      if (_G.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g1) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g1) == "number" then 
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g1) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g1) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (lua.Boot.__instanceof(v,Array)) then 
      c = Array;
    else
      local cl = v.__class__;
      if (cl ~= nil) then 
        c = cl;
      else
        c = nil;
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end

haxe.IMap.new = {}
haxe.IMap.__name__ = true

haxe.Json.new = {}
haxe.Json.__name__ = true
haxe.Json.parse = function(text) 
  do return haxe.format.JsonParser.new(text):parseRec() end;
end
haxe.Json.stringify = function(value,replacer,space) 
  do return haxe.format.JsonPrinter.print(value,replacer,space) end;
end

haxe.Log.new = {}
haxe.Log.__name__ = true
haxe.Log.trace = function(v,infos) 
  local str = nil;
  if (infos ~= nil) then 
    str = infos.fileName .. ":" .. infos.lineNumber .. ": " .. Std.string(v);
    if (infos.customParams ~= nil) then 
      str = str .. ("," .. infos.customParams:join(","));
    end;
  else
    str = v;
  end;
  if (str == nil) then 
    str = "null";
  end;
  _hx_print(str);
end

haxe.ds.StringMap.new = function() 
  local self = _hx_new(haxe.ds.StringMap.prototype)
  haxe.ds.StringMap.super(self)
  return self
end
haxe.ds.StringMap.super = function(self) 
  self.v = {}
  self.k = {}
end
haxe.ds.StringMap.__name__ = true
haxe.ds.StringMap.__interfaces__ = {haxe.IMap}
haxe.ds.StringMap.prototype = _hx_a(
  'keys', function(self) 
    local cur = _hx_tab_array({ }, 0);
    for _k,_v in pairs(self.k) do
			if(_v)then cur:push(_k) end
		end;
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
      local ret = cur:pop();
      do return ret end;
    end,hasNext=function(self) 
      do return cur.length > 0 end;
    end}) end
  end
  ,'__class__',  haxe.ds.StringMap
)

haxe.format.JsonParser.new = function(str) 
  local self = _hx_new(haxe.format.JsonParser.prototype)
  haxe.format.JsonParser.super(self,str)
  return self
end
haxe.format.JsonParser.super = function(self,str) 
  self.str = str;
  self.pos = 0;
end
haxe.format.JsonParser.__name__ = true
haxe.format.JsonParser.prototype = _hx_a(
  'parseRec', function(self) 
    while (true) do 
      local index = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local c = _G.string.byte(self.str,index + 1);
      local c1 = c;
      if (c1) == 9 or (c1) == 10 or (c1) == 13 or (c1) == 32 then 
      elseif (c1) == 34 then 
        do return self:parseString() end;
      elseif (c1) == 45 or (c1) == 48 or (c1) == 49 or (c1) == 50 or (c1) == 51 or (c1) == 52 or (c1) == 53 or (c1) == 54 or (c1) == 55 or (c1) == 56 or (c1) == 57 then 
        local c2 = c;
        local start = self.pos - 1;
        local minus = c2 == 45;
        local digit = not minus;
        local zero = c2 == 48;
        local point = false;
        local e = false;
        local pm = false;
        local _end = false;
        while (true) do 
          local index1 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          c2 = _G.string.byte(self.str,index1 + 1);
          local c3 = c2;
          if (c3) == 43 or (c3) == 45 then 
            if (not e or pm) then 
              self:invalidNumber(start);
            end;
            digit = false;
            pm = true;
          elseif (c3) == 46 then 
            if (minus or point) then 
              self:invalidNumber(start);
            end;
            digit = false;
            point = true;
          elseif (c3) == 48 then 
            if (zero and not point) then 
              self:invalidNumber(start);
            end;
            if (minus) then 
              minus = false;
              zero = true;
            end;
            digit = true;
          elseif (c3) == 49 or (c3) == 50 or (c3) == 51 or (c3) == 52 or (c3) == 53 or (c3) == 54 or (c3) == 55 or (c3) == 56 or (c3) == 57 then 
            if (zero and not point) then 
              self:invalidNumber(start);
            end;
            if (minus) then 
              minus = false;
            end;
            digit = true;
            zero = false;
          elseif (c3) == 69 or (c3) == 101 then 
            if ((minus or zero) or e) then 
              self:invalidNumber(start);
            end;
            digit = false;
            e = true;else
          if (not digit) then 
            self:invalidNumber(start);
          end;
          self.pos = self.pos - 1;
          _end = true; end;
          if (_end) then 
            break;
          end;
          end;
        local f = Std.parseFloat(self.str:substr(start,self.pos - start));
        local i = Std.int(f);
        if (i == f) then 
          do return i end;
        else
          do return f end;
        end;
      elseif (c1) == 91 then 
        local arr = _hx_tab_array({ }, 0);
        local comma = nil;
        while (true) do 
          local index2 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local c4 = _G.string.byte(self.str,index2 + 1);
          local c5 = c4;
          if (c5) == 9 or (c5) == 10 or (c5) == 13 or (c5) == 32 then 
          elseif (c5) == 44 then 
            if (comma) then 
              comma = false;
            else
              self:invalidChar();
            end;
          elseif (c5) == 93 then 
            if (comma == false) then 
              self:invalidChar();
            end;
            do return arr end;else
          if (comma) then 
            self:invalidChar();
          end;
          self.pos = self.pos - 1;
          arr:push(self:parseRec());
          comma = true; end;
          end;
      elseif (c1) == 102 then 
        local save = self.pos;
        local tmp;
        local tmp1;
        local tmp2;
        local index3 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index3 + 1) == 97) then 
          local index4 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp2 = _G.string.byte(self.str,index4 + 1) ~= 108;
        else
          tmp2 = true;
        end;
        if (not tmp2) then 
          local index5 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp1 = _G.string.byte(self.str,index5 + 1) ~= 115;
        else
          tmp1 = true;
        end;
        if (not tmp1) then 
          local index6 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp = _G.string.byte(self.str,index6 + 1) ~= 101;
        else
          tmp = true;
        end;
        if (tmp) then 
          self.pos = save;
          self:invalidChar();
        end;
        do return false end;
      elseif (c1) == 110 then 
        local save1 = self.pos;
        local tmp3;
        local tmp4;
        local index7 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index7 + 1) == 117) then 
          local index8 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp4 = _G.string.byte(self.str,index8 + 1) ~= 108;
        else
          tmp4 = true;
        end;
        if (not tmp4) then 
          local index9 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp3 = _G.string.byte(self.str,index9 + 1) ~= 108;
        else
          tmp3 = true;
        end;
        if (tmp3) then 
          self.pos = save1;
          self:invalidChar();
        end;
        do return nil end;
      elseif (c1) == 116 then 
        local save2 = self.pos;
        local tmp5;
        local tmp6;
        local index10 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index10 + 1) == 114) then 
          local index11 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp6 = _G.string.byte(self.str,index11 + 1) ~= 117;
        else
          tmp6 = true;
        end;
        if (not tmp6) then 
          local index12 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp5 = _G.string.byte(self.str,index12 + 1) ~= 101;
        else
          tmp5 = true;
        end;
        if (tmp5) then 
          self.pos = save2;
          self:invalidChar();
        end;
        do return true end;
      elseif (c1) == 123 then 
        local obj = _hx_e();
        local field = nil;
        local comma1 = nil;
        while (true) do 
          local index13 = (function() 
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local c6 = _G.string.byte(self.str,index13 + 1);
          local c7 = c6;
          if (c7) == 9 or (c7) == 10 or (c7) == 13 or (c7) == 32 then 
          elseif (c7) == 34 then 
            if (comma1) then 
              self:invalidChar();
            end;
            field = self:parseString();
          elseif (c7) == 44 then 
            if (comma1) then 
              comma1 = false;
            else
              self:invalidChar();
            end;
          elseif (c7) == 58 then 
            if (field == nil) then 
              self:invalidChar();
            end;
            obj[field] = self:parseRec();
            field = nil;
            comma1 = true;
          elseif (c7) == 125 then 
            if ((field ~= nil) or (comma1 == false)) then 
              self:invalidChar();
            end;
            do return obj end;else
          self:invalidChar(); end;
          end;else
      self:invalidChar(); end;
      end;
  end,
  'parseString', function(self) 
    local start = self.pos;
    local buf = nil;
    while (true) do 
      local index = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local c = _G.string.byte(self.str,index + 1);
      if (c == 34) then 
        break;
      end;
      if (c == 92) then 
        if (buf == nil) then 
          buf = StringBuf.new();
        end;
        local s = self.str;
        local len = (self.pos - start) - 1;
        local part = (function() 
          local _hx_1
          if (len == nil) then 
          _hx_1 = s:substr(start); else 
          _hx_1 = s:substr(start,len); end
          return _hx_1
        end )();
        _G.table.insert(buf.b,part);
        local buf1 = buf;
        buf1.length = buf1.length + part.length;
        local index1 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        c = _G.string.byte(self.str,index1 + 1);
        local c1 = c;
        if (c1) == 34 or (c1) == 47 or (c1) == 92 then 
          _G.table.insert(buf.b,_G.string.char(c));
          local buf2 = buf;
          buf2.length = buf2.length + 1;
        elseif (c1) == 98 then 
          _G.table.insert(buf.b,_G.string.char(8));
          local buf3 = buf;
          buf3.length = buf3.length + 1;
        elseif (c1) == 102 then 
          _G.table.insert(buf.b,_G.string.char(12));
          local buf4 = buf;
          buf4.length = buf4.length + 1;
        elseif (c1) == 110 then 
          _G.table.insert(buf.b,_G.string.char(10));
          local buf5 = buf;
          buf5.length = buf5.length + 1;
        elseif (c1) == 114 then 
          _G.table.insert(buf.b,_G.string.char(13));
          local buf6 = buf;
          buf6.length = buf6.length + 1;
        elseif (c1) == 116 then 
          _G.table.insert(buf.b,_G.string.char(9));
          local buf7 = buf;
          buf7.length = buf7.length + 1;
        elseif (c1) == 117 then 
          local uc = Std.parseInt("0x" .. self.str:substr(self.pos,4));
          local tmp = self;
          tmp.pos = tmp.pos + 4;
          if (uc <= 127) then 
            _G.table.insert(buf.b,_G.string.char(uc));
            local buf8 = buf;
            buf8.length = buf8.length + 1;
          else
            if (uc <= 2047) then 
              _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(192,_hx_bit.arshift(uc,6))));
              local buf9 = buf;
              buf9.length = buf9.length + 1;
              _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
              local buf10 = buf;
              buf10.length = buf10.length + 1;
            else
              if (uc <= 65535) then 
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(224,_hx_bit.arshift(uc,12))));
                local buf11 = buf;
                buf11.length = buf11.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,6),63))));
                local buf12 = buf;
                buf12.length = buf12.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
                local buf13 = buf;
                buf13.length = buf13.length + 1;
              else
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(240,_hx_bit.arshift(uc,18))));
                local buf14 = buf;
                buf14.length = buf14.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,12),63))));
                local buf15 = buf;
                buf15.length = buf15.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,6),63))));
                local buf16 = buf;
                buf16.length = buf16.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
                local buf17 = buf;
                buf17.length = buf17.length + 1;
              end;
            end;
          end;else
        _G.error("Invalid escape sequence \\" .. _G.string.char(c) .. " at position " .. (self.pos - 1),0); end;
        start = self.pos;
      else
        if (c == nil) then 
          _G.error("Unclosed string",0);
        end;
      end;
      end;
    if (buf == nil) then 
      do return self.str:substr(start,(self.pos - start) - 1) end;
    else
      local s1 = self.str;
      local len1 = (self.pos - start) - 1;
      local part1 = (function() 
        local _hx_2
        if (len1 == nil) then 
        _hx_2 = s1:substr(start); else 
        _hx_2 = s1:substr(start,len1); end
        return _hx_2
      end )();
      _G.table.insert(buf.b,part1);
      local buf18 = buf;
      buf18.length = buf18.length + part1.length;
      do return _G.table.concat(buf.b) end;
    end;
  end,
  'invalidChar', function(self) 
    self.pos = self.pos - 1;
    _G.error("Invalid char " .. _G.string.byte(self.str,self.pos + 1) .. " at position " .. self.pos,0);
  end,
  'invalidNumber', function(self,start) 
    _G.error("Invalid number at position " .. start .. ": " .. self.str:substr(start,self.pos - start),0);
  end
  ,'__class__',  haxe.format.JsonParser
)

haxe.format.JsonPrinter.new = function(replacer,space) 
  local self = _hx_new(haxe.format.JsonPrinter.prototype)
  haxe.format.JsonPrinter.super(self,replacer,space)
  return self
end
haxe.format.JsonPrinter.super = function(self,replacer,space) 
  self.replacer = _hx_funcToField(replacer);
  self.indent = space;
  self.pretty = space ~= nil;
  self.nind = 0;
  self.buf = StringBuf.new();
end
haxe.format.JsonPrinter.__name__ = true
haxe.format.JsonPrinter.print = function(o,replacer,space) 
  local printer = haxe.format.JsonPrinter.new(replacer,space);
  printer:write("",o);
  do return _G.table.concat(printer.buf.b) end;
end
haxe.format.JsonPrinter.prototype = _hx_a(
  'write', function(self,k,v) 
    if (self.replacer ~= nil) then 
      v = self:replacer(k,v);
    end;
    local _g = Type.typeof(v);
    local _g1 = _g[1];
    if (_g1) == 0 then 
      local _this = self.buf;
      local str = "null";
      _G.table.insert(_this.b,str);
      local _this1 = _this;
      _this1.length = _this1.length + str.length;
    elseif (_g1) == 1 then 
      local _this2 = self.buf;
      local str1 = Std.string(v);
      _G.table.insert(_this2.b,str1);
      local _this3 = _this2;
      _this3.length = _this3.length + str1.length;
    elseif (_g1) == 2 then 
      local _this4 = self.buf;
      local str2;
      local f = v;
      if ((f > -_G.math.huge) and (f < _G.math.huge)) then 
        str2 = v;
      else
        str2 = "null";
      end;
      local str3 = Std.string(str2);
      _G.table.insert(_this4.b,str3);
      local _this5 = _this4;
      _this5.length = _this5.length + str3.length;
    elseif (_g1) == 3 then 
      local _this6 = self.buf;
      local str4 = Std.string(v);
      _G.table.insert(_this6.b,str4);
      local _this7 = _this6;
      _this7.length = _this7.length + str4.length;
    elseif (_g1) == 4 then 
      self:fieldsString(v,Reflect.fields(v));
    elseif (_g1) == 5 then 
      local _this8 = self.buf;
      local str5 = "\"<fun>\"";
      _G.table.insert(_this8.b,str5);
      local _this9 = _this8;
      _this9.length = _this9.length + str5.length;
    elseif (_g1) == 6 then 
      local c = _g[2];
      if (c == String) then 
        self:quote(v);
      else
        if (c == Array) then 
          local v1 = v;
          local _this10 = self.buf;
          _G.table.insert(_this10.b,_G.string.char(91));
          local _this11 = _this10;
          _this11.length = _this11.length + 1;
          local len = v1.length;
          local last = len - 1;
          local _g11 = 0;
          local _g2 = len;
          while (_g11 < _g2) do 
            _g11 = _g11 + 1;
            local i = _g11 - 1;
            if (i > 0) then 
              local _this12 = self.buf;
              _G.table.insert(_this12.b,_G.string.char(44));
              local _this13 = _this12;
              _this13.length = _this13.length + 1;
            else
              self.nind = self.nind + 1;
            end;
            if (self.pretty) then 
              local _this14 = self.buf;
              _G.table.insert(_this14.b,_G.string.char(10));
              local _this15 = _this14;
              _this15.length = _this15.length + 1;
            end;
            if (self.pretty) then 
              local v2 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
              local _this16 = self.buf;
              local str6 = Std.string(v2);
              _G.table.insert(_this16.b,str6);
              local _this17 = _this16;
              _this17.length = _this17.length + str6.length;
            end;
            self:write(i,v1[i]);
            if (i == last) then 
              self.nind = self.nind - 1;
              if (self.pretty) then 
                local _this18 = self.buf;
                _G.table.insert(_this18.b,_G.string.char(10));
                local _this19 = _this18;
                _this19.length = _this19.length + 1;
              end;
              if (self.pretty) then 
                local v3 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
                local _this20 = self.buf;
                local str7 = Std.string(v3);
                _G.table.insert(_this20.b,str7);
                local _this21 = _this20;
                _this21.length = _this21.length + str7.length;
              end;
            end;
            end;
          local _this22 = self.buf;
          _G.table.insert(_this22.b,_G.string.char(93));
          local _this23 = _this22;
          _this23.length = _this23.length + 1;
        else
          if (c == haxe.ds.StringMap) then 
            local v4 = v;
            local o = _hx_e();
            local k1 = v4:keys();
            while (k1:hasNext()) do 
              local k2 = k1:next();
              o[k2] = v4.v[k2];
              end;
            self:fieldsString(o,Reflect.fields(o));
          else
            if (c == Date) then 
              local v5 = v;
              self:quote(lua.Boot.dateStr(v5));
            else
              self:fieldsString(v,Reflect.fields(v));
            end;
          end;
        end;
      end;
    elseif (_g1) == 7 then 
      local i1 = v[1];
      local _this24 = self.buf;
      local str8 = Std.string(i1);
      _G.table.insert(_this24.b,str8);
      local _this25 = _this24;
      _this25.length = _this25.length + str8.length;
    elseif (_g1) == 8 then 
      local _this26 = self.buf;
      local str9 = "\"???\"";
      _G.table.insert(_this26.b,str9);
      local _this27 = _this26;
      _this27.length = _this27.length + str9.length; end;
  end,
  'fieldsString', function(self,v,fields) 
    local _this = self.buf;
    _G.table.insert(_this.b,_G.string.char(123));
    local _this1 = _this;
    _this1.length = _this1.length + 1;
    local len = fields.length;
    local last = len - 1;
    local first = true;
    local _g1 = 0;
    local _g = len;
    local _hx_break_0 = false;
    while (_g1 < _g) do 
      repeat 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local f = fields[i];
      local value = Reflect.field(v,f);
      if (Reflect.isFunction(value)) then 
        break;
      end;
      if (first) then 
        self.nind = self.nind + 1;
        first = false;
      else
        local _this2 = self.buf;
        _G.table.insert(_this2.b,_G.string.char(44));
        local _this3 = _this2;
        _this3.length = _this3.length + 1;
      end;
      if (self.pretty) then 
        local _this4 = self.buf;
        _G.table.insert(_this4.b,_G.string.char(10));
        local _this5 = _this4;
        _this5.length = _this5.length + 1;
      end;
      if (self.pretty) then 
        local v1 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
        local _this6 = self.buf;
        local str = Std.string(v1);
        _G.table.insert(_this6.b,str);
        local _this7 = _this6;
        _this7.length = _this7.length + str.length;
      end;
      self:quote(f);
      local _this8 = self.buf;
      _G.table.insert(_this8.b,_G.string.char(58));
      local _this9 = _this8;
      _this9.length = _this9.length + 1;
      if (self.pretty) then 
        local _this10 = self.buf;
        _G.table.insert(_this10.b,_G.string.char(32));
        local _this11 = _this10;
        _this11.length = _this11.length + 1;
      end;
      self:write(f,value);
      if (i == last) then 
        self.nind = self.nind - 1;
        if (self.pretty) then 
          local _this12 = self.buf;
          _G.table.insert(_this12.b,_G.string.char(10));
          local _this13 = _this12;
          _this13.length = _this13.length + 1;
        end;
        if (self.pretty) then 
          local v2 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
          local _this14 = self.buf;
          local str1 = Std.string(v2);
          _G.table.insert(_this14.b,str1);
          local _this15 = _this14;
          _this15.length = _this15.length + str1.length;
        end;
      end;
      
    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    local _this16 = self.buf;
    _G.table.insert(_this16.b,_G.string.char(125));
    local _this17 = _this16;
    _this17.length = _this17.length + 1;
  end,
  'quote', function(self,s) 
    local _this = self.buf;
    _G.table.insert(_this.b,_G.string.char(34));
    local _this1 = _this;
    _this1.length = _this1.length + 1;
    local i = 0;
    while (true) do 
      i = i + 1;
      local c = _G.string.byte(s,(i - 1) + 1);
      if (c == nil) then 
        break;
      end;
      local c1 = c;
      if (c1) == 8 then 
        local _this2 = self.buf;
        local str = "\\b";
        _G.table.insert(_this2.b,str);
        local _this3 = _this2;
        _this3.length = _this3.length + str.length;
      elseif (c1) == 9 then 
        local _this4 = self.buf;
        local str1 = "\\t";
        _G.table.insert(_this4.b,str1);
        local _this5 = _this4;
        _this5.length = _this5.length + str1.length;
      elseif (c1) == 10 then 
        local _this6 = self.buf;
        local str2 = "\\n";
        _G.table.insert(_this6.b,str2);
        local _this7 = _this6;
        _this7.length = _this7.length + str2.length;
      elseif (c1) == 12 then 
        local _this8 = self.buf;
        local str3 = "\\f";
        _G.table.insert(_this8.b,str3);
        local _this9 = _this8;
        _this9.length = _this9.length + str3.length;
      elseif (c1) == 13 then 
        local _this10 = self.buf;
        local str4 = "\\r";
        _G.table.insert(_this10.b,str4);
        local _this11 = _this10;
        _this11.length = _this11.length + str4.length;
      elseif (c1) == 34 then 
        local _this12 = self.buf;
        local str5 = "\\\"";
        _G.table.insert(_this12.b,str5);
        local _this13 = _this12;
        _this13.length = _this13.length + str5.length;
      elseif (c1) == 92 then 
        local _this14 = self.buf;
        local str6 = "\\\\";
        _G.table.insert(_this14.b,str6);
        local _this15 = _this14;
        _this15.length = _this15.length + str6.length;else
      local _this16 = self.buf;
      _G.table.insert(_this16.b,_G.string.char(c));
      local _this17 = _this16;
      _this17.length = _this17.length + 1; end;
      end;
    local _this18 = self.buf;
    _G.table.insert(_this18.b,_G.string.char(34));
    local _this19 = _this18;
    _this19.length = _this19.length + 1;
  end
  ,'__class__',  haxe.format.JsonPrinter
)

haxe.io.Eof.new = {}
haxe.io.Eof.__name__ = true
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
  ,'__class__',  haxe.io.Eof
)

lua.Boot.new = {}
lua.Boot.__name__ = true
lua.Boot.getClass = function(o) 
  if (lua.Boot.__instanceof(o,Array)) then 
    do return Array end;
  else
    local cl = o.__class__;
    if (cl ~= nil) then 
      do return cl end;
    else
      do return nil end;
    end;
  end;
end
lua.Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return lua.Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return true end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == lua.Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == lua.UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    if (lua.Boot.extendsOrImplements(lua.Boot.getClass(o),cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_1
      if (cl == Class) then 
      _hx_1 = o.__name__ ~= nil; else 
      _hx_1 = false; end
      return _hx_1
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Enum) then 
      _hx_2 = o.__ename__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.dateStr = function(date) 
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return date:getFullYear() .. "-" .. ((function() 
    local _hx_1
    if (m < 10) then 
    _hx_1 = "0" .. m; else 
    _hx_1 = "" .. m; end
    return _hx_1
  end )()) .. "-" .. ((function() 
    local _hx_2
    if (d < 10) then 
    _hx_2 = "0" .. d; else 
    _hx_2 = "" .. d; end
    return _hx_2
  end )()) .. " " .. ((function() 
    local _hx_3
    if (h < 10) then 
    _hx_3 = "0" .. h; else 
    _hx_3 = "" .. h; end
    return _hx_3
  end )()) .. ":" .. ((function() 
    local _hx_4
    if (mi < 10) then 
    _hx_4 = "0" .. mi; else 
    _hx_4 = "" .. mi; end
    return _hx_4
  end )()) .. ":" .. ((function() 
    local _hx_5
    if (s < 10) then 
    _hx_5 = "0" .. s; else 
    _hx_5 = "" .. s; end
    return _hx_5
  end )()) end;
end
lua.Boot.strDate = function(s) 
  local _g = s.length;
  local _g1 = _g;
  if (_g1) == 8 then 
    local k = s:split(":");
    local t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=0,month=1,day=1,hour=_G.tonumber(k[0]),min=_G.tonumber(k[1]),sec=_G.tonumber(k[2])}));
    local d = _hx_e();
    _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = t / 1000;
    d.d = _G.os.date("*t",Std.int(d.t));
    do return d end;
  elseif (_g1) == 10 then 
    local k1 = s:split("-");
    do return Date.new(_G.tonumber(k1[0]),_G.tonumber(k1[1]) - 1,_G.tonumber(k1[2]),0,0,0) end;
  elseif (_g1) == 19 then 
    local k2 = s:split(" ");
    local y = k2[0]:split("-");
    local t1 = k2[1]:split(":");
    local tmp = _G.tonumber(y[1]) - 1;
    local tmp1 = _G.tonumber(y[2]);
    local tmp2 = _G.tonumber(t1[0]);
    local tmp3 = _G.tonumber(t1[1]);
    local tmp4 = _G.tonumber(t1[2]);
    do return Date.new(y[0],tmp,tmp1,tmp2,tmp3,tmp4) end;else
  _G.error("Invalid date format : " .. s,0); end;
end
lua.Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g1 = 1;
        local _g = _hx_table.maxn(intf) + 1;
        while (_g1 < _g) do 
          _g1 = _g1 + 1;
          local i = _g1 - 1;
          if (lua.Boot.extendsOrImplements(intf[i],cl2)) then 
            do return true end;
          end;
          end;
      end;
    end;
  end;
  do return lua.Boot.extendsOrImplements(cl1.__super__,cl2) end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end

lua.UserData.new = {}
lua.UserData.__name__ = true

lua.Thread.new = {}
lua.Thread.__name__ = true

sys.io.File.new = {}
sys.io.File.__name__ = true
sys.io.File.getContent = function(path) 
  local f = _G.io.open(path,"r");
  if (f == nil) then 
    _G.error("Invalid path : " .. path,0);
  end;
  local s = f:read("*all");
  f:close();
  do return s end;
end
_hx_bit_clamp = function(v) 
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end
pcall(require, 'bit')
if bit then
  _hx_bit = bit
elseif bit32 then
  local _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
  String.prototype.__class__ = String;
  String.__name__ = true;
  Array.__name__ = true;
end

_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else 
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end
_hx_funcToField = function(f)
  if type(f) == 'function' then 
    return function(self,...) 
      return f(...) 
    end
  else 
    return f
  end
end
_hx_print = print or (function() end)
_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;
_hx_static_init();
Main.main()
return _hx_exports
